{"mappings":"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","sources":["<anon>","node_modules/ol/geom/Circle.js","examples/groundvectors.js"],"sourcesContent":["import \"./buildings.88bb1910.js\";\nimport \"./buildings.81d58ce4.js\";\n\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire73bb\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire73bb\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"l7VLp\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $f6170f1a08d72585$export$2e2bcd8739ae039);\n/**\n * @module ol/geom/Circle\n */ \nvar $9pD6L = parcelRequire(\"9pD6L\");\n\nvar $h7zsK = parcelRequire(\"h7zsK\");\n\nvar $9bJty = parcelRequire(\"9bJty\");\n\nvar $1MAUi = parcelRequire(\"1MAUi\");\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */ class $f6170f1a08d72585$var$Circle extends (0, $h7zsK.default) {\n    /**\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   *     For internal use, flat coordinates in combination with `layout` and no\n   *     `radius` are also accepted.\n   * @param {number} [radius] Radius in units of the projection.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */ constructor(center, radius, layout){\n        super();\n        if (layout !== undefined && radius === undefined) this.setFlatCoordinates(layout, center);\n        else {\n            radius = radius ? radius : 0;\n            this.setCenterAndRadius(center, radius, layout);\n        }\n    }\n    /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @api\n   * @override\n   */ clone() {\n        const circle = new $f6170f1a08d72585$var$Circle(this.flatCoordinates.slice(), undefined, this.layout);\n        circle.applyProperties(this);\n        return circle;\n    }\n    /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {\n        const flatCoordinates = this.flatCoordinates;\n        const dx = x - flatCoordinates[0];\n        const dy = y - flatCoordinates[1];\n        const squaredDistance = dx * dx + dy * dy;\n        if (squaredDistance < minSquaredDistance) {\n            if (squaredDistance === 0) for(let i = 0; i < this.stride; ++i)closestPoint[i] = flatCoordinates[i];\n            else {\n                const delta = this.getRadius() / Math.sqrt(squaredDistance);\n                closestPoint[0] = flatCoordinates[0] + delta * dx;\n                closestPoint[1] = flatCoordinates[1] + delta * dy;\n                for(let i = 2; i < this.stride; ++i)closestPoint[i] = flatCoordinates[i];\n            }\n            closestPoint.length = this.stride;\n            return squaredDistance;\n        }\n        return minSquaredDistance;\n    }\n    /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   * @override\n   */ containsXY(x, y) {\n        const flatCoordinates = this.flatCoordinates;\n        const dx = x - flatCoordinates[0];\n        const dy = y - flatCoordinates[1];\n        return dx * dx + dy * dy <= this.getRadiusSquared_();\n    }\n    /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */ getCenter() {\n        return this.flatCoordinates.slice(0, this.stride);\n    }\n    /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @override\n   */ computeExtent(extent) {\n        const flatCoordinates = this.flatCoordinates;\n        const radius = flatCoordinates[this.stride] - flatCoordinates[0];\n        return (0, $9pD6L.createOrUpdate)(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);\n    }\n    /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */ getRadius() {\n        return Math.sqrt(this.getRadiusSquared_());\n    }\n    /**\n   * @private\n   * @return {number} Radius squared.\n   */ getRadiusSquared_() {\n        const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n        const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n        return dx * dx + dy * dy;\n    }\n    /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */ getType() {\n        return 'Circle';\n    }\n    /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */ intersectsExtent(extent) {\n        const circleExtent = this.getExtent();\n        if ((0, $9pD6L.intersects)(extent, circleExtent)) {\n            const center = this.getCenter();\n            if (extent[0] <= center[0] && extent[2] >= center[0]) return true;\n            if (extent[1] <= center[1] && extent[3] >= center[1]) return true;\n            return (0, $9pD6L.forEachCorner)(extent, this.intersectsCoordinate.bind(this));\n        }\n        return false;\n    }\n    /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */ setCenter(center) {\n        const stride = this.stride;\n        const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n        const flatCoordinates = center.slice();\n        flatCoordinates[stride] = flatCoordinates[0] + radius;\n        for(let i = 1; i < stride; ++i)flatCoordinates[stride + i] = center[i];\n        this.setFlatCoordinates(this.layout, flatCoordinates);\n        this.changed();\n    }\n    /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */ setCenterAndRadius(center, radius, layout) {\n        this.setLayout(layout, center, 0);\n        if (!this.flatCoordinates) this.flatCoordinates = [];\n        /** @type {Array<number>} */ const flatCoordinates = this.flatCoordinates;\n        let offset = (0, $9bJty.deflateCoordinate)(flatCoordinates, 0, center, this.stride);\n        flatCoordinates[offset++] = flatCoordinates[0] + radius;\n        for(let i = 1, ii = this.stride; i < ii; ++i)flatCoordinates[offset++] = flatCoordinates[i];\n        flatCoordinates.length = offset;\n        this.changed();\n    }\n    /**\n   * @override\n   */ getCoordinates() {\n        return null;\n    }\n    /**\n   * @override\n   */ setCoordinates(coordinates, layout) {}\n    /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */ setRadius(radius) {\n        this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n        this.changed();\n    }\n    /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   * @override\n   */ rotate(angle, anchor) {\n        const center = this.getCenter();\n        const stride = this.getStride();\n        this.setCenter((0, $1MAUi.rotate)(center, 0, center.length, stride, angle, anchor, center));\n        this.changed();\n    }\n}\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */ $f6170f1a08d72585$var$Circle.prototype.transform;\nvar $f6170f1a08d72585$export$2e2bcd8739ae039 = $f6170f1a08d72585$var$Circle;\n\n});\n\n\nvar $cc3xD = parcelRequire(\"cc3xD\");\n\nvar $9DiKA = parcelRequire(\"9DiKA\");\n\nvar $f3WAG = parcelRequire(\"f3WAG\");\n\nvar $9jDAx = parcelRequire(\"9jDAx\");\n\nvar $4mWlF = parcelRequire(\"4mWlF\");\n\nvar $cJntk = parcelRequire(\"cJntk\");\n\nvar $c3RIb = parcelRequire(\"c3RIb\");\n\nvar $lrKvI = parcelRequire(\"lrKvI\");\n\nvar $inIMS = parcelRequire(\"inIMS\");\n\nvar $5DwXE = parcelRequire(\"5DwXE\");\n\nvar $wnhPR = parcelRequire(\"wnhPR\");\n\nvar $bnthu = parcelRequire(\"bnthu\");\n\nvar $l7vEP = parcelRequire(\"l7vEP\");\n\nvar $bdrRp = parcelRequire(\"bdrRp\");\n\nvar $dIG9p = parcelRequire(\"dIG9p\");\n\nvar $l7VLp = parcelRequire(\"l7VLp\");\n\nvar $5gNCk = parcelRequire(\"5gNCk\");\nconst $112deb77f5ea721f$var$image = new (0, $wnhPR.default)({\n    radius: 5,\n    fill: null,\n    stroke: new (0, $lrKvI.default)({\n        color: 'red',\n        width: 1\n    })\n});\nconst $112deb77f5ea721f$var$styles = {\n    'Point': [\n        new (0, $c3RIb.default)({\n            image: $112deb77f5ea721f$var$image\n        })\n    ],\n    'LineString': [\n        new (0, $c3RIb.default)({\n            stroke: new (0, $lrKvI.default)({\n                color: 'green',\n                width: 2\n            })\n        })\n    ],\n    'MultiLineString': [\n        new (0, $c3RIb.default)({\n            stroke: new (0, $lrKvI.default)({\n                color: 'green',\n                width: 2\n            })\n        })\n    ],\n    'MultiPoint': [\n        new (0, $c3RIb.default)({\n            image: $112deb77f5ea721f$var$image,\n            text: new (0, $cJntk.default)({\n                text: 'MP',\n                stroke: new (0, $lrKvI.default)({\n                    color: 'purple'\n                })\n            })\n        })\n    ],\n    'MultiPolygon': [\n        new (0, $c3RIb.default)({\n            stroke: new (0, $lrKvI.default)({\n                color: 'yellow',\n                width: 1\n            }),\n            fill: new (0, $inIMS.default)({\n                color: 'rgba(255, 255, 0, 0.1)'\n            })\n        })\n    ],\n    'Polygon': [\n        new (0, $c3RIb.default)({\n            stroke: new (0, $lrKvI.default)({\n                color: 'blue',\n                width: 3\n            }),\n            fill: new (0, $inIMS.default)({\n                color: 'rgba(0, 0, 255, 0.1)'\n            })\n        })\n    ],\n    'GeometryCollection': [\n        new (0, $c3RIb.default)({\n            stroke: new (0, $lrKvI.default)({\n                color: 'magenta',\n                width: 2\n            }),\n            fill: new (0, $inIMS.default)({\n                color: 'magenta'\n            }),\n            image: new (0, $wnhPR.default)({\n                radius: 10,\n                fill: null,\n                stroke: new (0, $lrKvI.default)({\n                    color: 'magenta'\n                })\n            })\n        })\n    ],\n    'Circle': [\n        new (0, $c3RIb.default)({\n            stroke: new (0, $lrKvI.default)({\n                color: 'red',\n                width: 2\n            }),\n            fill: new (0, $inIMS.default)({\n                color: 'rgba(255,0,0,0.2)'\n            })\n        })\n    ]\n};\nconst $112deb77f5ea721f$var$styleFunction = function(feature, resolution) {\n    const geo = feature.getGeometry();\n    // always assign a style to prevent feature skipping\n    return geo ? $112deb77f5ea721f$var$styles[geo.getType()] : $112deb77f5ea721f$var$styles['Point'];\n};\nconst $112deb77f5ea721f$var$vectorSource = new (0, $bnthu.default)({\n    format: new (0, $l7vEP.default)(),\n    url: 'data/geojson/ground_vector_data.geojson' // la mettre en ref\n});\nconst $112deb77f5ea721f$var$vectorLayer = new (0, $bdrRp.default)({\n    source: $112deb77f5ea721f$var$vectorSource,\n    style: $112deb77f5ea721f$var$styleFunction\n});\n$112deb77f5ea721f$var$vectorLayer.getSource().addFeature(new (0, $dIG9p.default)({\n    geometry: new (0, $l7VLp.default)([\n        16880133.570042003,\n        -3565441.544459192\n    ], 200)\n}));\nconst $112deb77f5ea721f$var$map = new (0, $5DwXE.default)({\n    layers: [\n        new (0, $4mWlF.default)({\n            source: new (0, $9jDAx.default)()\n        }),\n        $112deb77f5ea721f$var$vectorLayer\n    ],\n    target: 'map2d',\n    controls: (0, $f3WAG.defaults)({\n        attributionOptions: {\n            collapsible: false\n        }\n    }),\n    view: new (0, $9DiKA.default)({\n        center: [\n            16880670.33392873,\n            -3565966.2275828626\n        ],\n        zoom: 15\n    })\n});\n$112deb77f5ea721f$var$vectorLayer.set('altitudeMode', 'clampToGround');\nconst $112deb77f5ea721f$var$ol3d = new (0, $cc3xD.default)({\n    map: $112deb77f5ea721f$var$map,\n    target: 'map3d'\n});\nconst $112deb77f5ea721f$var$scene = $112deb77f5ea721f$var$ol3d.getCesiumScene();\n$112deb77f5ea721f$var$ol3d.setEnabled(true);\nwindow['toggleClampToGround'] = function() {\n    let altitudeMode;\n    if (!$112deb77f5ea721f$var$vectorLayer.get('altitudeMode')) altitudeMode = 'clampToGround';\n    $112deb77f5ea721f$var$vectorLayer.set('altitudeMode', altitudeMode);\n    $112deb77f5ea721f$var$map.removeLayer($112deb77f5ea721f$var$vectorLayer);\n    $112deb77f5ea721f$var$map.addLayer($112deb77f5ea721f$var$vectorLayer);\n};\nwindow['ol3d'] = $112deb77f5ea721f$var$ol3d;\nwindow['scene'] = $112deb77f5ea721f$var$scene;\ndocument.getElementById('enable').addEventListener('click', ()=>$112deb77f5ea721f$var$ol3d.setEnabled(!$112deb77f5ea721f$var$ol3d.getEnabled()));\n$112deb77f5ea721f$var$ol3d.enableAutoRenderLoop();\n(0, $5gNCk.initCodeSandbox)('rawjs/groundvectors.js', 'data/geojson/ground_vector_data.geojson'); // faire à la demande\n // définir un objet\n // ex Ground vector titlre + urls list\n // introduire\n // voir\n //https://github.com/geoblocks/mapfishprint/tree/main/demo\n\n\n//# sourceMappingURL=groundvectors.ef6b417c.js.map\n","/**\n * @module ol/geom/Circle\n */\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {rotate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nclass Circle extends SimpleGeometry {\n  /**\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   *     For internal use, flat coordinates in combination with `layout` and no\n   *     `radius` are also accepted.\n   * @param {number} [radius] Radius in units of the projection.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(center, radius, layout) {\n    super();\n    if (layout !== undefined && radius === undefined) {\n      this.setFlatCoordinates(layout, center);\n    } else {\n      radius = radius ? radius : 0;\n      this.setCenterAndRadius(center, radius, layout);\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const circle = new Circle(\n      this.flatCoordinates.slice(),\n      undefined,\n      this.layout,\n    );\n    circle.applyProperties(this);\n    return circle;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    const squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (let i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        const delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (let i = 2; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   * @override\n   */\n  containsXY(x, y) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  }\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n  getCenter() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @override\n   */\n  computeExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(\n      flatCoordinates[0] - radius,\n      flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius,\n      flatCoordinates[1] + radius,\n      extent,\n    );\n  }\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return Math.sqrt(this.getRadiusSquared_());\n  }\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  getRadiusSquared_() {\n    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'Circle';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    const circleExtent = this.getExtent();\n    if (intersects(extent, circleExtent)) {\n      const center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n    }\n    return false;\n  }\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n  setCenter(center) {\n    const stride = this.stride;\n    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    const flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (let i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  }\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCenterAndRadius(center, radius, layout) {\n    this.setLayout(layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n    const flatCoordinates = this.flatCoordinates;\n    let offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (let i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  }\n\n  /**\n   * @override\n   */\n  getCoordinates() {\n    return null;\n  }\n\n  /**\n   * @override\n   */\n  setCoordinates(coordinates, layout) {}\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  setRadius(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   * @override\n   */\n  rotate(angle, anchor) {\n    const center = this.getCenter();\n    const stride = this.getStride();\n    this.setCenter(\n      rotate(center, 0, center.length, stride, angle, anchor, center),\n    );\n    this.changed();\n  }\n}\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n","import OLCesium from 'olcs';\nimport olView from 'ol/View.js';\nimport {defaults as olControlDefaults} from 'ol/control.js';\nimport olSourceOSM from 'ol/source/OSM.js';\nimport olLayerTile from 'ol/layer/Tile.js';\nimport olStyleText from 'ol/style/Text.js';\nimport olStyleStyle from 'ol/style/Style.js';\nimport olStyleStroke from 'ol/style/Stroke.js';\nimport olStyleFill from 'ol/style/Fill.js';\nimport olMap from 'ol/Map.js';\nimport olStyleCircle from 'ol/style/Circle.js';\nimport olSourceVector from 'ol/source/Vector.js';\nimport olFormatGeoJSON from 'ol/format/GeoJSON.js';\nimport olLayerVector from 'ol/layer/Vector.js';\nimport olFeature from 'ol/Feature.js';\nimport olCircle from 'ol/geom/Circle.js';\n\nconst image = new olStyleCircle({\n  radius: 5,\n  fill: null,\n  stroke: new olStyleStroke({color: 'red', width: 1})\n});\n\nconst styles = {\n  'Point': [new olStyleStyle({\n    image\n  })],\n  'LineString': [new olStyleStyle({\n    stroke: new olStyleStroke({\n      color: 'green',\n      width: 2\n    })\n  })],\n  'MultiLineString': [new olStyleStyle({\n    stroke: new olStyleStroke({\n      color: 'green',\n      width: 2\n    })\n  })],\n  'MultiPoint': [new olStyleStyle({\n    image,\n    text: new olStyleText({\n      text: 'MP',\n      stroke: new olStyleStroke({\n        color: 'purple'\n      })\n    })\n  })],\n  'MultiPolygon': [new olStyleStyle({\n    stroke: new olStyleStroke({\n      color: 'yellow',\n      width: 1\n    }),\n    fill: new olStyleFill({\n      color: 'rgba(255, 255, 0, 0.1)'\n    })\n  })],\n  'Polygon': [new olStyleStyle({\n    stroke: new olStyleStroke({\n      color: 'blue',\n      width: 3\n    }),\n    fill: new olStyleFill({\n      color: 'rgba(0, 0, 255, 0.1)'\n    })\n  })],\n  'GeometryCollection': [new olStyleStyle({\n    stroke: new olStyleStroke({\n      color: 'magenta',\n      width: 2\n    }),\n    fill: new olStyleFill({\n      color: 'magenta'\n    }),\n    image: new olStyleCircle({\n      radius: 10, // pixels\n      fill: null,\n      stroke: new olStyleStroke({\n        color: 'magenta'\n      })\n    })\n  })],\n  'Circle': [new olStyleStyle({\n    stroke: new olStyleStroke({\n      color: 'red',\n      width: 2\n    }),\n    fill: new olStyleFill({\n      color: 'rgba(255,0,0,0.2)'\n    })\n  })]\n};\n\nconst styleFunction = function(feature, resolution) {\n  const geo = feature.getGeometry();\n  // always assign a style to prevent feature skipping\n  return geo ? styles[geo.getType()] : styles['Point'];\n};\n\nconst vectorSource = new olSourceVector({\n  format: new olFormatGeoJSON(),\n  url: 'data/geojson/ground_vector_data.geojson' // la mettre en ref\n});\n\nconst vectorLayer = new olLayerVector({\n  source: vectorSource,\n  style: styleFunction\n});\n\nvectorLayer.getSource().addFeature(new olFeature({\n  geometry: new olCircle([16880133.570042003, -3565441.544459192], 200)\n}));\n\nconst map = new olMap({\n  layers: [\n    new olLayerTile({\n      source: new olSourceOSM()\n    }),\n    vectorLayer,\n  ],\n  target: 'map2d',\n  controls: olControlDefaults({\n    attributionOptions: {\n      collapsible: false\n    }\n  }),\n  view: new olView({\n    center: [16880670.33392873, -3565966.2275828626],\n    zoom: 15\n  })\n});\n\nvectorLayer.set('altitudeMode', 'clampToGround');\nconst ol3d = new OLCesium({map, target: 'map3d'});\nconst scene = ol3d.getCesiumScene();\nol3d.setEnabled(true);\n\nwindow['toggleClampToGround'] = function() {\n  let altitudeMode;\n  if (!vectorLayer.get('altitudeMode')) {\n    altitudeMode = 'clampToGround';\n  }\n  vectorLayer.set('altitudeMode', altitudeMode);\n  map.removeLayer(vectorLayer);\n  map.addLayer(vectorLayer);\n};\n\nwindow['ol3d'] = ol3d;\nwindow['scene'] = scene;\ndocument.getElementById('enable').addEventListener('click', () => ol3d.setEnabled(!ol3d.getEnabled()));\n\nol3d.enableAutoRenderLoop();\n\n//##REMOVE## Keep this tag, split code here for code sandbox\n\nimport {initCodeSandbox} from './_code-sandbox.js';\ninitCodeSandbox('rawjs/groundvectors.js', 'data/geojson/ground_vector_data.geojson');\n\n// faire à la demande\n// définir un objet\n// ex Ground vector titlre + urls list\n// introduire\n\n\n// voir\n//https://github.com/geoblocks/mapfishprint/tree/main/demo\n\n"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","Object","defineProperty","get","$f6170f1a08d72585$export$2e2bcd8739ae039","set","s","enumerable","configurable","$9pD6L","$h7zsK","$9bJty","$1MAUi","$f6170f1a08d72585$var$Circle","default","constructor","center","radius","layout","undefined","setFlatCoordinates","setCenterAndRadius","clone","circle","flatCoordinates","slice","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","dx","dy","squaredDistance","i","stride","delta","getRadius","Math","sqrt","length","containsXY","getRadiusSquared_","getCenter","computeExtent","extent","createOrUpdate","getType","intersectsExtent","circleExtent","getExtent","intersects","forEachCorner","intersectsCoordinate","bind","setCenter","changed","setLayout","offset","deflateCoordinate","ii","getCoordinates","setCoordinates","coordinates","setRadius","rotate","angle","anchor","getStride","prototype","transform","$cc3xD","$9DiKA","$f3WAG","$9jDAx","$4mWlF","$cJntk","$c3RIb","$lrKvI","$inIMS","$5DwXE","$wnhPR","$bnthu","$l7vEP","$bdrRp","$dIG9p","$l7VLp","$5gNCk","$112deb77f5ea721f$var$image","fill","stroke","color","width","$112deb77f5ea721f$var$styles","image","text","$112deb77f5ea721f$var$vectorSource","format","url","$112deb77f5ea721f$var$vectorLayer","source","style","feature","resolution","geo","getGeometry","getSource","addFeature","geometry","$112deb77f5ea721f$var$map","layers","target","controls","defaults","attributionOptions","collapsible","view","zoom","$112deb77f5ea721f$var$ol3d","map","$112deb77f5ea721f$var$scene","getCesiumScene","setEnabled","window","altitudeMode","removeLayer","addLayer","document","getElementById","addEventListener","getEnabled","enableAutoRenderLoop","initCodeSandbox"],"version":3,"file":"groundvectors.ef6b417c.js.map"}