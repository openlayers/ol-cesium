{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,U,I,GCEC,IAAA,EAAA,EAAA,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,QA0DD,OAAM,UAAgB,EAAA,OAAU,CAI9B,YAAY,CAAO,CAAE,CACnB,EAAU,GAAoB,CAAC,EAE/B,KAAK,GAKL,IAAI,CAAC,cAAc,CAAG,AAAA,CAAA,EAAA,EAAA,GAAY,AAAZ,EACpB,EAAQ,cAAc,CAAG,EAAQ,cAAc,CAAG,aAGhD,EAAQ,iBAAiB,EAI3B,CAAA,IAAI,CAAC,wBAAwB,CAAG,AAAA,CAAA,EAAA,EAAA,GAAY,AAAZ,EAAc,EAAQ,iBAAiB,CAAA,EAGrE,EAAQ,YAAY,EACtB,CAAA,IAAI,CAAC,YAAY,CAAG,EAAQ,YAAY,AAAZ,EAQ9B,IAAI,CAAC,aAAa,CAAG,EAAQ,YAAY,CAOzC,IAAI,CAAC,oBAAoB,CAAG,EAAQ,mBAAmB,CAEvD,IAAI,CAAC,mBAAmB,CAAG,CACzB,uBACA,2BACD,AACH,CASA,sBAAsB,CAAM,CAAE,CAAO,CAAE,CAIrC,IAAI,EAAiB,KAWf,EAAW,EAAqB,CATpC,EADE,AAAmB,YAAnB,EAAO,IAAO,CACgC,EAE/B,CACf,KAAQ,UACR,SAA4C,EAC5C,WAAc,IAChB,GAGmD,QAAW,CAAE,GAClE,GAAI,IAAI,CAAC,YAAY,GAAK,EAAA,OAAY,CACpC,MACE,AAAA,CAAA,EAAA,EAAA,mBAAkB,AAAlB,EACE,CACE,SAAA,EACA,GAAI,EAAe,EAAK,CACxB,WAAY,EAAe,UAAa,AAC1C,EACA,GAKN,IAAM,EAAU,GAAI,CAAA,EAAA,EAAA,OAAM,AAAN,E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","sources":["<anon>","node_modules/ol/format/GeoJSON.js","node_modules/ol/format/JSONFeature.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire73bb\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire73bb\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"l7vEP\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $f602cef51a2e6950$export$2e2bcd8739ae039);\n/**\n * @module ol/format/GeoJSON\n */ \nvar $dIG9p = parcelRequire(\"dIG9p\");\n\nvar $h7zsK = parcelRequire(\"h7zsK\");\n\nvar $9bJty = parcelRequire(\"9bJty\");\n\nvar $gn0g3 = parcelRequire(\"gn0g3\");\n\nvar $dpRHA = parcelRequire(\"dpRHA\");\n\nvar $4HUbK = parcelRequire(\"4HUbK\");\n\nvar $kgouC = parcelRequire(\"kgouC\");\n\nvar $45uGP = parcelRequire(\"45uGP\");\n/**\n * @typedef {import(\"geojson\").GeoJSON} GeoJSONObject\n * @typedef {import(\"geojson\").Feature} GeoJSONFeature\n * @typedef {import(\"geojson\").FeatureCollection} GeoJSONFeatureCollection\n * @typedef {import(\"geojson\").Geometry} GeoJSONGeometry\n * @typedef {import(\"geojson\").Point} GeoJSONPoint\n * @typedef {import(\"geojson\").LineString} GeoJSONLineString\n * @typedef {import(\"geojson\").Polygon} GeoJSONPolygon\n * @typedef {import(\"geojson\").MultiPoint} GeoJSONMultiPoint\n * @typedef {import(\"geojson\").MultiLineString} GeoJSONMultiLineString\n * @typedef {import(\"geojson\").MultiPolygon} GeoJSONMultiPolygon\n * @typedef {import(\"geojson\").GeometryCollection} GeoJSONGeometryCollection\n */ /**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @typedef {Object} Options\n *\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection for features read or\n * written by the format.  Options passed to read or write methods will take precedence.\n * @property {string} [geometryName] Geometry name to use when creating features.\n * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include\n * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader\n * will look for that field to set the geometry name. If both this field is set to `true`\n * and a `geometryName` is provided, the `geometryName` will take precedence.\n * @property {import('./Feature.js').FeatureToFeatureClass<FeatureType>} [featureClass] Feature class\n * to be used when reading features. The default is {@link module:ol/Feature~Feature}. If performance is\n * the primary concern, and features are not going to be modified or round-tripped through the format,\n * consider using {@link module:ol/render/Feature~RenderFeature}\n */ /**\n * @classdesc\n * Feature format for reading and writing data in the GeoJSON format.\n *\n * @template {import('../Feature.js').FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @extends {JSONFeature<FeatureType>}\n * @api\n */ class $f602cef51a2e6950$var$GeoJSON extends (0, $45uGP.default) {\n    /**\n   * @param {Options<FeatureType>} [options] Options.\n   */ constructor(options){\n        options = options ? options : {};\n        super();\n        /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */ this.dataProjection = (0, $dpRHA.get)(options.dataProjection ? options.dataProjection : 'EPSG:4326');\n        if (options.featureProjection) /**\n       * @type {import(\"../proj/Projection.js\").default}\n       */ this.defaultFeatureProjection = (0, $dpRHA.get)(options.featureProjection);\n        if (options.featureClass) this.featureClass = options.featureClass;\n        /**\n     * Name of the geometry attribute for features.\n     * @type {string|undefined}\n     * @private\n     */ this.geometryName_ = options.geometryName;\n        /**\n     * Look for the `geometry_name` in the feature GeoJSON\n     * @type {boolean|undefined}\n     * @private\n     */ this.extractGeometryName_ = options.extractGeometryName;\n        this.supportedMediaTypes = [\n            'application/geo+json',\n            'application/vnd.geo+json'\n        ];\n    }\n    /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   * @override\n   */ readFeatureFromObject(object, options) {\n        /**\n     * @type {GeoJSONFeature}\n     */ let geoJSONFeature = null;\n        if (object['type'] === 'Feature') geoJSONFeature = /** @type {GeoJSONFeature} */ object;\n        else geoJSONFeature = {\n            'type': 'Feature',\n            'geometry': /** @type {GeoJSONGeometry} */ object,\n            'properties': null\n        };\n        const geometry = $f602cef51a2e6950$var$readGeometryInternal(geoJSONFeature['geometry'], options);\n        if (this.featureClass === (0, $4HUbK.default)) return /** @type {FeatureType|Array<FeatureType>} */ (0, $kgouC.createRenderFeature)({\n            geometry: geometry,\n            id: geoJSONFeature['id'],\n            properties: geoJSONFeature['properties']\n        }, options);\n        const feature = new (0, $dIG9p.default)();\n        if (this.geometryName_) feature.setGeometryName(this.geometryName_);\n        else if (this.extractGeometryName_ && geoJSONFeature['geometry_name']) feature.setGeometryName(geoJSONFeature['geometry_name']);\n        feature.setGeometry((0, $kgouC.createGeometry)(geometry, options));\n        if ('id' in geoJSONFeature) feature.setId(geoJSONFeature['id']);\n        if (geoJSONFeature['properties']) feature.setProperties(geoJSONFeature['properties'], true);\n        return /** @type {FeatureType|Array<FeatureType>} */ feature;\n    }\n    /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<FeatureType>} Features.\n   * @override\n   */ readFeaturesFromObject(object, options) {\n        const geoJSONObject = /** @type {GeoJSONObject} */ object;\n        let features = null;\n        if (geoJSONObject['type'] === 'FeatureCollection') {\n            const geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ object;\n            features = [];\n            const geoJSONFeatures = geoJSONFeatureCollection['features'];\n            for(let i = 0, ii = geoJSONFeatures.length; i < ii; ++i){\n                const featureObject = this.readFeatureFromObject(geoJSONFeatures[i], options);\n                if (!featureObject) continue;\n                features.push(featureObject);\n            }\n        } else features = [\n            this.readFeatureFromObject(object, options)\n        ];\n        return /** @type {Array<FeatureType>} */ features.flat();\n    }\n    /**\n   * @param {GeoJSONGeometry} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @override\n   */ readGeometryFromObject(object, options) {\n        return $f602cef51a2e6950$var$readGeometry(object, options);\n    }\n    /**\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @override\n   */ readProjectionFromObject(object) {\n        const crs = object['crs'];\n        let projection;\n        if (crs) {\n            if (crs['type'] == 'name') projection = (0, $dpRHA.get)(crs['properties']['name']);\n            else if (crs['type'] === 'EPSG') projection = (0, $dpRHA.get)('EPSG:' + crs['properties']['code']);\n            else throw new Error('Unknown SRS type');\n        } else projection = this.dataProjection;\n        return /** @type {import(\"../proj/Projection.js\").default} */ projection;\n    }\n    /**\n   * Encode a feature as a GeoJSON Feature object.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONFeature} Object.\n   * @api\n   * @override\n   */ writeFeatureObject(feature, options) {\n        options = this.adaptOptions(options);\n        /** @type {GeoJSONFeature} */ const object = {\n            'type': 'Feature',\n            geometry: null,\n            properties: null\n        };\n        const id = feature.getId();\n        if (id !== undefined) object.id = id;\n        if (!feature.hasProperties()) return object;\n        const properties = feature.getProperties();\n        const geometry = feature.getGeometry();\n        if (geometry) {\n            object.geometry = $f602cef51a2e6950$var$writeGeometry(geometry, options);\n            delete properties[feature.getGeometryName()];\n        }\n        if (!(0, $gn0g3.isEmpty)(properties)) object.properties = properties;\n        return object;\n    }\n    /**\n   * Encode an array of features as a GeoJSON object.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONFeatureCollection} GeoJSON Object.\n   * @api\n   * @override\n   */ writeFeaturesObject(features, options) {\n        options = this.adaptOptions(options);\n        const objects = [];\n        for(let i = 0, ii = features.length; i < ii; ++i)objects.push(this.writeFeatureObject(features[i], options));\n        return {\n            type: 'FeatureCollection',\n            features: objects\n        };\n    }\n    /**\n   * Encode a geometry as a GeoJSON object.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.\n   * @api\n   * @override\n   */ writeGeometryObject(geometry, options) {\n        return $f602cef51a2e6950$var$writeGeometry(geometry, this.adaptOptions(options));\n    }\n}\n/**\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"./Feature.js\").GeometryObject} Geometry.\n */ function $f602cef51a2e6950$var$readGeometryInternal(object, options) {\n    if (!object) return null;\n    /** @type {import(\"./Feature.js\").GeometryObject} */ let geometry;\n    switch(object['type']){\n        case 'Point':\n            geometry = $f602cef51a2e6950$var$readPointGeometry(/** @type {GeoJSONPoint} */ object);\n            break;\n        case 'LineString':\n            geometry = $f602cef51a2e6950$var$readLineStringGeometry(/** @type {GeoJSONLineString} */ object);\n            break;\n        case 'Polygon':\n            geometry = $f602cef51a2e6950$var$readPolygonGeometry(/** @type {GeoJSONPolygon} */ object);\n            break;\n        case 'MultiPoint':\n            geometry = $f602cef51a2e6950$var$readMultiPointGeometry(/** @type {GeoJSONMultiPoint} */ object);\n            break;\n        case 'MultiLineString':\n            geometry = $f602cef51a2e6950$var$readMultiLineStringGeometry(/** @type {GeoJSONMultiLineString} */ object);\n            break;\n        case 'MultiPolygon':\n            geometry = $f602cef51a2e6950$var$readMultiPolygonGeometry(/** @type {GeoJSONMultiPolygon} */ object);\n            break;\n        case 'GeometryCollection':\n            geometry = $f602cef51a2e6950$var$readGeometryCollectionGeometry(/** @type {GeoJSONGeometryCollection} */ object);\n            break;\n        default:\n            throw new Error('Unsupported GeoJSON type: ' + object['type']);\n    }\n    return geometry;\n}\n/**\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */ function $f602cef51a2e6950$var$readGeometry(object, options) {\n    const geometryObject = $f602cef51a2e6950$var$readGeometryInternal(object, options);\n    return (0, $kgouC.createGeometry)(geometryObject, options);\n}\n/**\n * @param {GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"./Feature.js\").GeometryCollectionObject} Geometry collection.\n */ function $f602cef51a2e6950$var$readGeometryCollectionGeometry(object, options) {\n    const geometries = object['geometries'].map(/**\n     * @param {GeoJSONGeometry} geometry Geometry.\n     * @return {import(\"./Feature.js\").GeometryObject} geometry Geometry.\n     */ function(geometry) {\n        return $f602cef51a2e6950$var$readGeometryInternal(geometry, options);\n    });\n    return geometries;\n}\n/**\n * @param {GeoJSONPoint} object Input object.\n * @return {import(\"./Feature.js\").GeometryObject} Point geometry.\n */ function $f602cef51a2e6950$var$readPointGeometry(object) {\n    const flatCoordinates = object['coordinates'];\n    return {\n        type: 'Point',\n        flatCoordinates: flatCoordinates,\n        layout: (0, $h7zsK.getLayoutForStride)(flatCoordinates.length)\n    };\n}\n/**\n * @param {GeoJSONLineString} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} LineString geometry.\n */ function $f602cef51a2e6950$var$readLineStringGeometry(object) {\n    const coordinates = object['coordinates'];\n    const flatCoordinates = coordinates.flat();\n    return {\n        type: 'LineString',\n        flatCoordinates: flatCoordinates,\n        ends: [\n            flatCoordinates.length\n        ],\n        layout: (0, $h7zsK.getLayoutForStride)(coordinates[0]?.length || 2)\n    };\n}\n/**\n * @param {GeoJSONMultiLineString} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} MultiLineString geometry.\n */ function $f602cef51a2e6950$var$readMultiLineStringGeometry(object) {\n    const coordinates = object['coordinates'];\n    const stride = coordinates[0]?.[0]?.length || 2;\n    const flatCoordinates = [];\n    const ends = (0, $9bJty.deflateCoordinatesArray)(flatCoordinates, 0, coordinates, stride);\n    return {\n        type: 'MultiLineString',\n        flatCoordinates: flatCoordinates,\n        ends: ends,\n        layout: (0, $h7zsK.getLayoutForStride)(stride)\n    };\n}\n/**\n * @param {GeoJSONMultiPoint} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} MultiPoint geometry.\n */ function $f602cef51a2e6950$var$readMultiPointGeometry(object) {\n    const coordinates = object['coordinates'];\n    return {\n        type: 'MultiPoint',\n        flatCoordinates: coordinates.flat(),\n        layout: (0, $h7zsK.getLayoutForStride)(coordinates[0]?.length || 2)\n    };\n}\n/**\n * @param {GeoJSONMultiPolygon} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} MultiPolygon geometry.\n */ function $f602cef51a2e6950$var$readMultiPolygonGeometry(object) {\n    const coordinates = object['coordinates'];\n    const flatCoordinates = [];\n    const stride = coordinates[0]?.[0]?.[0].length || 2;\n    const endss = (0, $9bJty.deflateMultiCoordinatesArray)(flatCoordinates, 0, coordinates, stride);\n    return {\n        type: 'MultiPolygon',\n        flatCoordinates: flatCoordinates,\n        ends: endss,\n        layout: (0, $h7zsK.getLayoutForStride)(stride)\n    };\n}\n/**\n * @param {GeoJSONPolygon} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} Polygon.\n */ function $f602cef51a2e6950$var$readPolygonGeometry(object) {\n    const coordinates = object['coordinates'];\n    const flatCoordinates = [];\n    const stride = coordinates[0]?.[0]?.length;\n    const ends = (0, $9bJty.deflateCoordinatesArray)(flatCoordinates, 0, coordinates, stride);\n    return {\n        type: 'Polygon',\n        flatCoordinates: flatCoordinates,\n        ends: ends,\n        layout: (0, $h7zsK.getLayoutForStride)(stride)\n    };\n}\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */ function $f602cef51a2e6950$var$writeGeometry(geometry, options) {\n    geometry = (0, $kgouC.transformGeometryWithOptions)(geometry, true, options);\n    const type = geometry.getType();\n    /** @type {GeoJSONGeometry} */ let geoJSON;\n    switch(type){\n        case 'Point':\n            geoJSON = $f602cef51a2e6950$var$writePointGeometry(/** @type {import(\"../geom/Point.js\").default} */ geometry, options);\n            break;\n        case 'LineString':\n            geoJSON = $f602cef51a2e6950$var$writeLineStringGeometry(/** @type {import(\"../geom/LineString.js\").default} */ geometry, options);\n            break;\n        case 'Polygon':\n            geoJSON = $f602cef51a2e6950$var$writePolygonGeometry(/** @type {import(\"../geom/Polygon.js\").default} */ geometry, options);\n            break;\n        case 'MultiPoint':\n            geoJSON = $f602cef51a2e6950$var$writeMultiPointGeometry(/** @type {import(\"../geom/MultiPoint.js\").default} */ geometry, options);\n            break;\n        case 'MultiLineString':\n            geoJSON = $f602cef51a2e6950$var$writeMultiLineStringGeometry(/** @type {import(\"../geom/MultiLineString.js\").default} */ geometry, options);\n            break;\n        case 'MultiPolygon':\n            geoJSON = $f602cef51a2e6950$var$writeMultiPolygonGeometry(/** @type {import(\"../geom/MultiPolygon.js\").default} */ geometry, options);\n            break;\n        case 'GeometryCollection':\n            geoJSON = $f602cef51a2e6950$var$writeGeometryCollectionGeometry(/** @type {import(\"../geom/GeometryCollection.js\").default} */ geometry, options);\n            break;\n        case 'Circle':\n            geoJSON = {\n                type: 'GeometryCollection',\n                geometries: []\n            };\n            break;\n        default:\n            throw new Error('Unsupported geometry type: ' + type);\n    }\n    return geoJSON;\n}\n/**\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.\n */ function $f602cef51a2e6950$var$writeGeometryCollectionGeometry(geometry, options) {\n    options = Object.assign({}, options);\n    delete options.featureProjection;\n    const geometries = geometry.getGeometriesArray().map(function(geometry) {\n        return $f602cef51a2e6950$var$writeGeometry(geometry, options);\n    });\n    return {\n        type: 'GeometryCollection',\n        geometries: geometries\n    };\n}\n/**\n * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */ function $f602cef51a2e6950$var$writeLineStringGeometry(geometry, options) {\n    return {\n        type: 'LineString',\n        coordinates: geometry.getCoordinates()\n    };\n}\n/**\n * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */ function $f602cef51a2e6950$var$writeMultiLineStringGeometry(geometry, options) {\n    return {\n        type: 'MultiLineString',\n        coordinates: geometry.getCoordinates()\n    };\n}\n/**\n * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */ function $f602cef51a2e6950$var$writeMultiPointGeometry(geometry, options) {\n    return {\n        type: 'MultiPoint',\n        coordinates: geometry.getCoordinates()\n    };\n}\n/**\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */ function $f602cef51a2e6950$var$writeMultiPolygonGeometry(geometry, options) {\n    let right;\n    if (options) right = options.rightHanded;\n    return {\n        type: 'MultiPolygon',\n        coordinates: geometry.getCoordinates(right)\n    };\n}\n/**\n * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */ function $f602cef51a2e6950$var$writePointGeometry(geometry, options) {\n    return {\n        type: 'Point',\n        coordinates: geometry.getCoordinates()\n    };\n}\n/**\n * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */ function $f602cef51a2e6950$var$writePolygonGeometry(geometry, options) {\n    let right;\n    if (options) right = options.rightHanded;\n    return {\n        type: 'Polygon',\n        coordinates: geometry.getCoordinates(right)\n    };\n}\nvar $f602cef51a2e6950$export$2e2bcd8739ae039 = $f602cef51a2e6950$var$GeoJSON;\n\n});\nparcelRegister(\"45uGP\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $2f9f6f6b6e1ba437$export$2e2bcd8739ae039);\n/**\n * @module ol/format/JSONFeature\n */ \nvar $9iPUS = parcelRequire(\"9iPUS\");\n\nvar $kgouC = parcelRequire(\"kgouC\");\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for JSON feature formats.\n *\n * @template {import('../Feature.js').FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @extends {FeatureFormat<FeatureType>}\n * @abstract\n */ class $2f9f6f6b6e1ba437$var$JSONFeature extends (0, $kgouC.default) {\n    constructor(){\n        super();\n    }\n    /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   * @override\n   */ getType() {\n        return 'json';\n    }\n    /**\n   * Read a feature.  Only works for a single feature. Use `readFeatures` to\n   * read a feature collection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   * @api\n   * @override\n   */ readFeature(source, options) {\n        return this.readFeatureFromObject($2f9f6f6b6e1ba437$var$getObject(source), this.getReadOptions(source, options));\n    }\n    /**\n   * Read all features.  Works with both a single feature and a feature\n   * collection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   * @override\n   */ readFeatures(source, options) {\n        return this.readFeaturesFromObject($2f9f6f6b6e1ba437$var$getObject(source), this.getReadOptions(source, options));\n    }\n    /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   */ readFeatureFromObject(object, options) {\n        return (0, $9iPUS.abstract)();\n    }\n    /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<FeatureType>} Features.\n   */ readFeaturesFromObject(object, options) {\n        return (0, $9iPUS.abstract)();\n    }\n    /**\n   * Read a geometry.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   * @override\n   */ readGeometry(source, options) {\n        return this.readGeometryFromObject($2f9f6f6b6e1ba437$var$getObject(source), this.getReadOptions(source, options));\n    }\n    /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */ readGeometryFromObject(object, options) {\n        return (0, $9iPUS.abstract)();\n    }\n    /**\n   * Read the projection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   * @override\n   */ readProjection(source) {\n        return this.readProjectionFromObject($2f9f6f6b6e1ba437$var$getObject(source));\n    }\n    /**\n   * @abstract\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */ readProjectionFromObject(object) {\n        return (0, $9iPUS.abstract)();\n    }\n    /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   * @api\n   * @override\n   */ writeFeature(feature, options) {\n        return JSON.stringify(this.writeFeatureObject(feature, options));\n    }\n    /**\n   * @abstract\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */ writeFeatureObject(feature, options) {\n        return (0, $9iPUS.abstract)();\n    }\n    /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded features.\n   * @api\n   * @override\n   */ writeFeatures(features, options) {\n        return JSON.stringify(this.writeFeaturesObject(features, options));\n    }\n    /**\n   * @abstract\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */ writeFeaturesObject(features, options) {\n        return (0, $9iPUS.abstract)();\n    }\n    /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded geometry.\n   * @api\n   * @override\n   */ writeGeometry(geometry, options) {\n        return JSON.stringify(this.writeGeometryObject(geometry, options));\n    }\n    /**\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */ writeGeometryObject(geometry, options) {\n        return (0, $9iPUS.abstract)();\n    }\n}\n/**\n * @param {Document|Element|Object|string} source Source.\n * @return {Object} Object.\n */ function $2f9f6f6b6e1ba437$var$getObject(source) {\n    if (typeof source === 'string') {\n        const object = JSON.parse(source);\n        return object ? /** @type {Object} */ object : null;\n    }\n    if (source !== null) return source;\n    return null;\n}\nvar $2f9f6f6b6e1ba437$export$2e2bcd8739ae039 = $2f9f6f6b6e1ba437$var$JSONFeature;\n\n});\n\n\n\n//# sourceMappingURL=buildings.81d58ce4.js.map\n","/**\n * @module ol/format/GeoJSON\n */\n\nimport Feature from '../Feature.js';\nimport {getLayoutForStride} from '../geom/SimpleGeometry.js';\nimport {\n  deflateCoordinatesArray,\n  deflateMultiCoordinatesArray,\n} from '../geom/flat/deflate.js';\nimport {isEmpty} from '../obj.js';\nimport {get as getProjection} from '../proj.js';\nimport RenderFeature from '../render/Feature.js';\nimport {\n  createGeometry,\n  createRenderFeature,\n  transformGeometryWithOptions,\n} from './Feature.js';\nimport JSONFeature from './JSONFeature.js';\n\n/**\n * @typedef {import(\"geojson\").GeoJSON} GeoJSONObject\n * @typedef {import(\"geojson\").Feature} GeoJSONFeature\n * @typedef {import(\"geojson\").FeatureCollection} GeoJSONFeatureCollection\n * @typedef {import(\"geojson\").Geometry} GeoJSONGeometry\n * @typedef {import(\"geojson\").Point} GeoJSONPoint\n * @typedef {import(\"geojson\").LineString} GeoJSONLineString\n * @typedef {import(\"geojson\").Polygon} GeoJSONPolygon\n * @typedef {import(\"geojson\").MultiPoint} GeoJSONMultiPoint\n * @typedef {import(\"geojson\").MultiLineString} GeoJSONMultiLineString\n * @typedef {import(\"geojson\").MultiPolygon} GeoJSONMultiPolygon\n * @typedef {import(\"geojson\").GeometryCollection} GeoJSONGeometryCollection\n */\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @typedef {Object} Options\n *\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection for features read or\n * written by the format.  Options passed to read or write methods will take precedence.\n * @property {string} [geometryName] Geometry name to use when creating features.\n * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include\n * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader\n * will look for that field to set the geometry name. If both this field is set to `true`\n * and a `geometryName` is provided, the `geometryName` will take precedence.\n * @property {import('./Feature.js').FeatureToFeatureClass<FeatureType>} [featureClass] Feature class\n * to be used when reading features. The default is {@link module:ol/Feature~Feature}. If performance is\n * the primary concern, and features are not going to be modified or round-tripped through the format,\n * consider using {@link module:ol/render/Feature~RenderFeature}\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GeoJSON format.\n *\n * @template {import('../Feature.js').FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @extends {JSONFeature<FeatureType>}\n * @api\n */\nclass GeoJSON extends JSONFeature {\n  /**\n   * @param {Options<FeatureType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super();\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection(\n      options.dataProjection ? options.dataProjection : 'EPSG:4326',\n    );\n\n    if (options.featureProjection) {\n      /**\n       * @type {import(\"../proj/Projection.js\").default}\n       */\n      this.defaultFeatureProjection = getProjection(options.featureProjection);\n    }\n\n    if (options.featureClass) {\n      this.featureClass = options.featureClass;\n    }\n\n    /**\n     * Name of the geometry attribute for features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * Look for the `geometry_name` in the feature GeoJSON\n     * @type {boolean|undefined}\n     * @private\n     */\n    this.extractGeometryName_ = options.extractGeometryName;\n\n    this.supportedMediaTypes = [\n      'application/geo+json',\n      'application/vnd.geo+json',\n    ];\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   * @override\n   */\n  readFeatureFromObject(object, options) {\n    /**\n     * @type {GeoJSONFeature}\n     */\n    let geoJSONFeature = null;\n    if (object['type'] === 'Feature') {\n      geoJSONFeature = /** @type {GeoJSONFeature} */ (object);\n    } else {\n      geoJSONFeature = {\n        'type': 'Feature',\n        'geometry': /** @type {GeoJSONGeometry} */ (object),\n        'properties': null,\n      };\n    }\n\n    const geometry = readGeometryInternal(geoJSONFeature['geometry'], options);\n    if (this.featureClass === RenderFeature) {\n      return /** @type {FeatureType|Array<FeatureType>} */ (\n        createRenderFeature(\n          {\n            geometry,\n            id: geoJSONFeature['id'],\n            properties: geoJSONFeature['properties'],\n          },\n          options,\n        )\n      );\n    }\n\n    const feature = new Feature();\n    if (this.geometryName_) {\n      feature.setGeometryName(this.geometryName_);\n    } else if (this.extractGeometryName_ && geoJSONFeature['geometry_name']) {\n      feature.setGeometryName(geoJSONFeature['geometry_name']);\n    }\n    feature.setGeometry(createGeometry(geometry, options));\n\n    if ('id' in geoJSONFeature) {\n      feature.setId(geoJSONFeature['id']);\n    }\n\n    if (geoJSONFeature['properties']) {\n      feature.setProperties(geoJSONFeature['properties'], true);\n    }\n    return /** @type {FeatureType|Array<FeatureType>} */ (feature);\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<FeatureType>} Features.\n   * @override\n   */\n  readFeaturesFromObject(object, options) {\n    const geoJSONObject = /** @type {GeoJSONObject} */ (object);\n    let features = null;\n    if (geoJSONObject['type'] === 'FeatureCollection') {\n      const geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ (\n        object\n      );\n      features = [];\n      const geoJSONFeatures = geoJSONFeatureCollection['features'];\n      for (let i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {\n        const featureObject = this.readFeatureFromObject(\n          geoJSONFeatures[i],\n          options,\n        );\n        if (!featureObject) {\n          continue;\n        }\n        features.push(featureObject);\n      }\n    } else {\n      features = [this.readFeatureFromObject(object, options)];\n    }\n    return /** @type {Array<FeatureType>} */ (features.flat());\n  }\n\n  /**\n   * @param {GeoJSONGeometry} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @override\n   */\n  readGeometryFromObject(object, options) {\n    return readGeometry(object, options);\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @override\n   */\n  readProjectionFromObject(object) {\n    const crs = object['crs'];\n    let projection;\n    if (crs) {\n      if (crs['type'] == 'name') {\n        projection = getProjection(crs['properties']['name']);\n      } else if (crs['type'] === 'EPSG') {\n        projection = getProjection('EPSG:' + crs['properties']['code']);\n      } else {\n        throw new Error('Unknown SRS type');\n      }\n    } else {\n      projection = this.dataProjection;\n    }\n    return /** @type {import(\"../proj/Projection.js\").default} */ (projection);\n  }\n\n  /**\n   * Encode a feature as a GeoJSON Feature object.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONFeature} Object.\n   * @api\n   * @override\n   */\n  writeFeatureObject(feature, options) {\n    options = this.adaptOptions(options);\n\n    /** @type {GeoJSONFeature} */\n    const object = {\n      'type': 'Feature',\n      geometry: null,\n      properties: null,\n    };\n\n    const id = feature.getId();\n    if (id !== undefined) {\n      object.id = id;\n    }\n\n    if (!feature.hasProperties()) {\n      return object;\n    }\n\n    const properties = feature.getProperties();\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      object.geometry = writeGeometry(geometry, options);\n\n      delete properties[feature.getGeometryName()];\n    }\n\n    if (!isEmpty(properties)) {\n      object.properties = properties;\n    }\n\n    return object;\n  }\n\n  /**\n   * Encode an array of features as a GeoJSON object.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONFeatureCollection} GeoJSON Object.\n   * @api\n   * @override\n   */\n  writeFeaturesObject(features, options) {\n    options = this.adaptOptions(options);\n    const objects = [];\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      objects.push(this.writeFeatureObject(features[i], options));\n    }\n    return {\n      type: 'FeatureCollection',\n      features: objects,\n    };\n  }\n\n  /**\n   * Encode a geometry as a GeoJSON object.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.\n   * @api\n   * @override\n   */\n  writeGeometryObject(geometry, options) {\n    return writeGeometry(geometry, this.adaptOptions(options));\n  }\n}\n\n/**\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"./Feature.js\").GeometryObject} Geometry.\n */\nfunction readGeometryInternal(object, options) {\n  if (!object) {\n    return null;\n  }\n\n  /** @type {import(\"./Feature.js\").GeometryObject} */\n  let geometry;\n  switch (object['type']) {\n    case 'Point': {\n      geometry = readPointGeometry(/** @type {GeoJSONPoint} */ (object));\n      break;\n    }\n    case 'LineString': {\n      geometry = readLineStringGeometry(\n        /** @type {GeoJSONLineString} */ (object),\n      );\n      break;\n    }\n    case 'Polygon': {\n      geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */ (object));\n      break;\n    }\n    case 'MultiPoint': {\n      geometry = readMultiPointGeometry(\n        /** @type {GeoJSONMultiPoint} */ (object),\n      );\n      break;\n    }\n    case 'MultiLineString': {\n      geometry = readMultiLineStringGeometry(\n        /** @type {GeoJSONMultiLineString} */ (object),\n      );\n      break;\n    }\n    case 'MultiPolygon': {\n      geometry = readMultiPolygonGeometry(\n        /** @type {GeoJSONMultiPolygon} */ (object),\n      );\n      break;\n    }\n    case 'GeometryCollection': {\n      geometry = readGeometryCollectionGeometry(\n        /** @type {GeoJSONGeometryCollection} */ (object),\n      );\n      break;\n    }\n    default: {\n      throw new Error('Unsupported GeoJSON type: ' + object['type']);\n    }\n  }\n  return geometry;\n}\n\n/**\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readGeometry(object, options) {\n  const geometryObject = readGeometryInternal(object, options);\n  return createGeometry(geometryObject, options);\n}\n\n/**\n * @param {GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"./Feature.js\").GeometryCollectionObject} Geometry collection.\n */\nfunction readGeometryCollectionGeometry(object, options) {\n  const geometries = object['geometries'].map(\n    /**\n     * @param {GeoJSONGeometry} geometry Geometry.\n     * @return {import(\"./Feature.js\").GeometryObject} geometry Geometry.\n     */\n    function (geometry) {\n      return readGeometryInternal(geometry, options);\n    },\n  );\n  return geometries;\n}\n\n/**\n * @param {GeoJSONPoint} object Input object.\n * @return {import(\"./Feature.js\").GeometryObject} Point geometry.\n */\nfunction readPointGeometry(object) {\n  const flatCoordinates = object['coordinates'];\n  return {\n    type: 'Point',\n    flatCoordinates,\n    layout: getLayoutForStride(flatCoordinates.length),\n  };\n}\n\n/**\n * @param {GeoJSONLineString} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} LineString geometry.\n */\nfunction readLineStringGeometry(object) {\n  const coordinates = object['coordinates'];\n  const flatCoordinates = coordinates.flat();\n  return {\n    type: 'LineString',\n    flatCoordinates,\n    ends: [flatCoordinates.length],\n    layout: getLayoutForStride(coordinates[0]?.length || 2),\n  };\n}\n\n/**\n * @param {GeoJSONMultiLineString} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} MultiLineString geometry.\n */\nfunction readMultiLineStringGeometry(object) {\n  const coordinates = object['coordinates'];\n  const stride = coordinates[0]?.[0]?.length || 2;\n  const flatCoordinates = [];\n  const ends = deflateCoordinatesArray(flatCoordinates, 0, coordinates, stride);\n  return {\n    type: 'MultiLineString',\n    flatCoordinates,\n    ends,\n    layout: getLayoutForStride(stride),\n  };\n}\n\n/**\n * @param {GeoJSONMultiPoint} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} MultiPoint geometry.\n */\nfunction readMultiPointGeometry(object) {\n  const coordinates = object['coordinates'];\n  return {\n    type: 'MultiPoint',\n    flatCoordinates: coordinates.flat(),\n    layout: getLayoutForStride(coordinates[0]?.length || 2),\n  };\n}\n\n/**\n * @param {GeoJSONMultiPolygon} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} MultiPolygon geometry.\n */\nfunction readMultiPolygonGeometry(object) {\n  const coordinates = object['coordinates'];\n  const flatCoordinates = [];\n  const stride = coordinates[0]?.[0]?.[0].length || 2;\n  const endss = deflateMultiCoordinatesArray(\n    flatCoordinates,\n    0,\n    coordinates,\n    stride,\n  );\n  return {\n    type: 'MultiPolygon',\n    flatCoordinates,\n    ends: endss,\n    layout: getLayoutForStride(stride),\n  };\n}\n\n/**\n * @param {GeoJSONPolygon} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} Polygon.\n */\nfunction readPolygonGeometry(object) {\n  const coordinates = object['coordinates'];\n  const flatCoordinates = [];\n  const stride = coordinates[0]?.[0]?.length;\n  const ends = deflateCoordinatesArray(flatCoordinates, 0, coordinates, stride);\n  return {\n    type: 'Polygon',\n    flatCoordinates,\n    ends,\n    layout: getLayoutForStride(stride),\n  };\n}\n\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeGeometry(geometry, options) {\n  geometry = transformGeometryWithOptions(geometry, true, options);\n\n  const type = geometry.getType();\n\n  /** @type {GeoJSONGeometry} */\n  let geoJSON;\n  switch (type) {\n    case 'Point': {\n      geoJSON = writePointGeometry(\n        /** @type {import(\"../geom/Point.js\").default} */ (geometry),\n        options,\n      );\n      break;\n    }\n    case 'LineString': {\n      geoJSON = writeLineStringGeometry(\n        /** @type {import(\"../geom/LineString.js\").default} */ (geometry),\n        options,\n      );\n      break;\n    }\n    case 'Polygon': {\n      geoJSON = writePolygonGeometry(\n        /** @type {import(\"../geom/Polygon.js\").default} */ (geometry),\n        options,\n      );\n      break;\n    }\n    case 'MultiPoint': {\n      geoJSON = writeMultiPointGeometry(\n        /** @type {import(\"../geom/MultiPoint.js\").default} */ (geometry),\n        options,\n      );\n      break;\n    }\n    case 'MultiLineString': {\n      geoJSON = writeMultiLineStringGeometry(\n        /** @type {import(\"../geom/MultiLineString.js\").default} */ (geometry),\n        options,\n      );\n      break;\n    }\n    case 'MultiPolygon': {\n      geoJSON = writeMultiPolygonGeometry(\n        /** @type {import(\"../geom/MultiPolygon.js\").default} */ (geometry),\n        options,\n      );\n      break;\n    }\n    case 'GeometryCollection': {\n      geoJSON = writeGeometryCollectionGeometry(\n        /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\n          geometry\n        ),\n        options,\n      );\n      break;\n    }\n    case 'Circle': {\n      geoJSON = {\n        type: 'GeometryCollection',\n        geometries: [],\n      };\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return geoJSON;\n}\n\n/**\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.\n */\nfunction writeGeometryCollectionGeometry(geometry, options) {\n  options = Object.assign({}, options);\n  delete options.featureProjection;\n  const geometries = geometry.getGeometriesArray().map(function (geometry) {\n    return writeGeometry(geometry, options);\n  });\n  return {\n    type: 'GeometryCollection',\n    geometries: geometries,\n  };\n}\n\n/**\n * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeLineStringGeometry(geometry, options) {\n  return {\n    type: 'LineString',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiLineStringGeometry(geometry, options) {\n  return {\n    type: 'MultiLineString',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPointGeometry(geometry, options) {\n  return {\n    type: 'MultiPoint',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPolygonGeometry(geometry, options) {\n  let right;\n  if (options) {\n    right = options.rightHanded;\n  }\n  return {\n    type: 'MultiPolygon',\n    coordinates: geometry.getCoordinates(right),\n  };\n}\n\n/**\n * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePointGeometry(geometry, options) {\n  return {\n    type: 'Point',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePolygonGeometry(geometry, options) {\n  let right;\n  if (options) {\n    right = options.rightHanded;\n  }\n  return {\n    type: 'Polygon',\n    coordinates: geometry.getCoordinates(right),\n  };\n}\n\nexport default GeoJSON;\n","/**\n * @module ol/format/JSONFeature\n */\nimport {abstract} from '../util.js';\nimport FeatureFormat from './Feature.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for JSON feature formats.\n *\n * @template {import('../Feature.js').FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @extends {FeatureFormat<FeatureType>}\n * @abstract\n */\nclass JSONFeature extends FeatureFormat {\n  constructor() {\n    super();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   * @override\n   */\n  getType() {\n    return 'json';\n  }\n\n  /**\n   * Read a feature.  Only works for a single feature. Use `readFeatures` to\n   * read a feature collection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   * @api\n   * @override\n   */\n  readFeature(source, options) {\n    return this.readFeatureFromObject(\n      getObject(source),\n      this.getReadOptions(source, options),\n    );\n  }\n\n  /**\n   * Read all features.  Works with both a single feature and a feature\n   * collection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   * @override\n   */\n  readFeatures(source, options) {\n    return this.readFeaturesFromObject(\n      getObject(source),\n      this.getReadOptions(source, options),\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   */\n  readFeatureFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<FeatureType>} Features.\n   */\n  readFeaturesFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a geometry.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   * @override\n   */\n  readGeometry(source, options) {\n    return this.readGeometryFromObject(\n      getObject(source),\n      this.getReadOptions(source, options),\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   * @override\n   */\n  readProjection(source) {\n    return this.readProjectionFromObject(getObject(source));\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromObject(object) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   * @api\n   * @override\n   */\n  writeFeature(feature, options) {\n    return JSON.stringify(this.writeFeatureObject(feature, options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeFeatureObject(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded features.\n   * @api\n   * @override\n   */\n  writeFeatures(features, options) {\n    return JSON.stringify(this.writeFeaturesObject(features, options));\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeFeaturesObject(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded geometry.\n   * @api\n   * @override\n   */\n  writeGeometry(geometry, options) {\n    return JSON.stringify(this.writeGeometryObject(geometry, options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeGeometryObject(geometry, options) {\n    return abstract();\n  }\n}\n\n/**\n * @param {Document|Element|Object|string} source Source.\n * @return {Object} Object.\n */\nfunction getObject(source) {\n  if (typeof source === 'string') {\n    const object = JSON.parse(source);\n    return object ? /** @type {Object} */ (object) : null;\n  }\n  if (source !== null) {\n    return source;\n  }\n  return null;\n}\n\nexport default JSONFeature;\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$f602cef51a2e6950$export$2e2bcd8739ae039","$dIG9p","$h7zsK","$9bJty","$gn0g3","$dpRHA","$4HUbK","$kgouC","$45uGP","$f602cef51a2e6950$var$GeoJSON","default","constructor","options","dataProjection","featureProjection","defaultFeatureProjection","featureClass","geometryName_","geometryName","extractGeometryName_","extractGeometryName","supportedMediaTypes","readFeatureFromObject","object","geoJSONFeature","geometry","$f602cef51a2e6950$var$readGeometryInternal","createRenderFeature","properties","feature","setGeometryName","setGeometry","createGeometry","setId","setProperties","readFeaturesFromObject","features","geoJSONObject","geoJSONFeatures","geoJSONFeatureCollection","i","ii","length","featureObject","push","flat","readGeometryFromObject","geometryObject","readProjectionFromObject","projection","crs","writeFeatureObject","adaptOptions","getId","undefined","hasProperties","getProperties","getGeometry","$f602cef51a2e6950$var$writeGeometry","getGeometryName","isEmpty","writeFeaturesObject","objects","type","writeGeometryObject","$f602cef51a2e6950$var$readPointGeometry","flatCoordinates","layout","getLayoutForStride","$f602cef51a2e6950$var$readLineStringGeometry","coordinates","ends","$f602cef51a2e6950$var$readPolygonGeometry","stride","deflateCoordinatesArray","$f602cef51a2e6950$var$readMultiPointGeometry","$f602cef51a2e6950$var$readMultiLineStringGeometry","$f602cef51a2e6950$var$readMultiPolygonGeometry","endss","deflateMultiCoordinatesArray","map","geoJSON","right","transformGeometryWithOptions","getType","getCoordinates","rightHanded","assign","geometries","getGeometriesArray","$2f9f6f6b6e1ba437$export$2e2bcd8739ae039","$9iPUS","$2f9f6f6b6e1ba437$var$JSONFeature","readFeature","source","$2f9f6f6b6e1ba437$var$getObject","getReadOptions","readFeatures","abstract","readGeometry","readProjection","writeFeature","JSON","stringify","writeFeatures","writeGeometry","parse"],"version":3,"file":"buildings.81d58ce4.js.map"}